// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tsm.proto

#ifndef PROTOBUF_tsm_2eproto__INCLUDED
#define PROTOBUF_tsm_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_tsm_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[8];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsUserNameImpl();
void InitDefaultsUserName();
void InitDefaultsUserIdImpl();
void InitDefaultsUserId();
void InitDefaultsFollowCommandImpl();
void InitDefaultsFollowCommand();
void InitDefaultsUnfollowCommandImpl();
void InitDefaultsUnfollowCommand();
void InitDefaultsGeneralStatusImpl();
void InitDefaultsGeneralStatus();
void InitDefaultsListReplyImpl();
void InitDefaultsListReply();
void InitDefaultsClientPostImpl();
void InitDefaultsClientPost();
void InitDefaultsServerPostImpl();
void InitDefaultsServerPost();
inline void InitDefaults() {
  InitDefaultsUserName();
  InitDefaultsUserId();
  InitDefaultsFollowCommand();
  InitDefaultsUnfollowCommand();
  InitDefaultsGeneralStatus();
  InitDefaultsListReply();
  InitDefaultsClientPost();
  InitDefaultsServerPost();
}
}  // namespace protobuf_tsm_2eproto
namespace tsm {
class ClientPost;
class ClientPostDefaultTypeInternal;
extern ClientPostDefaultTypeInternal _ClientPost_default_instance_;
class FollowCommand;
class FollowCommandDefaultTypeInternal;
extern FollowCommandDefaultTypeInternal _FollowCommand_default_instance_;
class GeneralStatus;
class GeneralStatusDefaultTypeInternal;
extern GeneralStatusDefaultTypeInternal _GeneralStatus_default_instance_;
class ListReply;
class ListReplyDefaultTypeInternal;
extern ListReplyDefaultTypeInternal _ListReply_default_instance_;
class ServerPost;
class ServerPostDefaultTypeInternal;
extern ServerPostDefaultTypeInternal _ServerPost_default_instance_;
class UnfollowCommand;
class UnfollowCommandDefaultTypeInternal;
extern UnfollowCommandDefaultTypeInternal _UnfollowCommand_default_instance_;
class UserId;
class UserIdDefaultTypeInternal;
extern UserIdDefaultTypeInternal _UserId_default_instance_;
class UserName;
class UserNameDefaultTypeInternal;
extern UserNameDefaultTypeInternal _UserName_default_instance_;
}  // namespace tsm
namespace tsm {

enum GStatus {
  SUCCESS = 0,
  FAILURE_ALREADY_EXISTS = 1,
  FAILURE_NOT_EXISTS = 2,
  FAILURE_INVALID_USERNAME = 3,
  FAILURE_INVALID = 4,
  FAILURE_UNKNOWN = 5,
  GStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  GStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool GStatus_IsValid(int value);
const GStatus GStatus_MIN = SUCCESS;
const GStatus GStatus_MAX = FAILURE_UNKNOWN;
const int GStatus_ARRAYSIZE = GStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* GStatus_descriptor();
inline const ::std::string& GStatus_Name(GStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    GStatus_descriptor(), value);
}
inline bool GStatus_Parse(
    const ::std::string& name, GStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GStatus>(
    GStatus_descriptor(), name, value);
}
// ===================================================================

class UserName : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tsm.UserName) */ {
 public:
  UserName();
  virtual ~UserName();

  UserName(const UserName& from);

  inline UserName& operator=(const UserName& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserName(UserName&& from) noexcept
    : UserName() {
    *this = ::std::move(from);
  }

  inline UserName& operator=(UserName&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserName& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserName* internal_default_instance() {
    return reinterpret_cast<const UserName*>(
               &_UserName_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(UserName* other);
  friend void swap(UserName& a, UserName& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserName* New() const PROTOBUF_FINAL { return New(NULL); }

  UserName* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserName& from);
  void MergeFrom(const UserName& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserName* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:tsm.UserName)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable int _cached_size_;
  friend struct ::protobuf_tsm_2eproto::TableStruct;
  friend void ::protobuf_tsm_2eproto::InitDefaultsUserNameImpl();
};
// -------------------------------------------------------------------

class UserId : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tsm.UserId) */ {
 public:
  UserId();
  virtual ~UserId();

  UserId(const UserId& from);

  inline UserId& operator=(const UserId& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserId(UserId&& from) noexcept
    : UserId() {
    *this = ::std::move(from);
  }

  inline UserId& operator=(UserId&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UserId& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserId* internal_default_instance() {
    return reinterpret_cast<const UserId*>(
               &_UserId_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(UserId* other);
  friend void swap(UserId& a, UserId& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserId* New() const PROTOBUF_FINAL { return New(NULL); }

  UserId* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UserId& from);
  void MergeFrom(const UserId& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UserId* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tsm.UserId)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 id_;
  mutable int _cached_size_;
  friend struct ::protobuf_tsm_2eproto::TableStruct;
  friend void ::protobuf_tsm_2eproto::InitDefaultsUserIdImpl();
};
// -------------------------------------------------------------------

class FollowCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tsm.FollowCommand) */ {
 public:
  FollowCommand();
  virtual ~FollowCommand();

  FollowCommand(const FollowCommand& from);

  inline FollowCommand& operator=(const FollowCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FollowCommand(FollowCommand&& from) noexcept
    : FollowCommand() {
    *this = ::std::move(from);
  }

  inline FollowCommand& operator=(FollowCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FollowCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FollowCommand* internal_default_instance() {
    return reinterpret_cast<const FollowCommand*>(
               &_FollowCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(FollowCommand* other);
  friend void swap(FollowCommand& a, FollowCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FollowCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  FollowCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FollowCommand& from);
  void MergeFrom(const FollowCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FollowCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nameToFollow = 2;
  void clear_nametofollow();
  static const int kNameToFollowFieldNumber = 2;
  const ::std::string& nametofollow() const;
  void set_nametofollow(const ::std::string& value);
  #if LANG_CXX11
  void set_nametofollow(::std::string&& value);
  #endif
  void set_nametofollow(const char* value);
  void set_nametofollow(const char* value, size_t size);
  ::std::string* mutable_nametofollow();
  ::std::string* release_nametofollow();
  void set_allocated_nametofollow(::std::string* nametofollow);

  // int64 sender = 1;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  ::google::protobuf::int64 sender() const;
  void set_sender(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tsm.FollowCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nametofollow_;
  ::google::protobuf::int64 sender_;
  mutable int _cached_size_;
  friend struct ::protobuf_tsm_2eproto::TableStruct;
  friend void ::protobuf_tsm_2eproto::InitDefaultsFollowCommandImpl();
};
// -------------------------------------------------------------------

class UnfollowCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tsm.UnfollowCommand) */ {
 public:
  UnfollowCommand();
  virtual ~UnfollowCommand();

  UnfollowCommand(const UnfollowCommand& from);

  inline UnfollowCommand& operator=(const UnfollowCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UnfollowCommand(UnfollowCommand&& from) noexcept
    : UnfollowCommand() {
    *this = ::std::move(from);
  }

  inline UnfollowCommand& operator=(UnfollowCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const UnfollowCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UnfollowCommand* internal_default_instance() {
    return reinterpret_cast<const UnfollowCommand*>(
               &_UnfollowCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(UnfollowCommand* other);
  friend void swap(UnfollowCommand& a, UnfollowCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UnfollowCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  UnfollowCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const UnfollowCommand& from);
  void MergeFrom(const UnfollowCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(UnfollowCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string nameToUnfollow = 2;
  void clear_nametounfollow();
  static const int kNameToUnfollowFieldNumber = 2;
  const ::std::string& nametounfollow() const;
  void set_nametounfollow(const ::std::string& value);
  #if LANG_CXX11
  void set_nametounfollow(::std::string&& value);
  #endif
  void set_nametounfollow(const char* value);
  void set_nametounfollow(const char* value, size_t size);
  ::std::string* mutable_nametounfollow();
  ::std::string* release_nametounfollow();
  void set_allocated_nametounfollow(::std::string* nametounfollow);

  // int64 sender = 1;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  ::google::protobuf::int64 sender() const;
  void set_sender(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tsm.UnfollowCommand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nametounfollow_;
  ::google::protobuf::int64 sender_;
  mutable int _cached_size_;
  friend struct ::protobuf_tsm_2eproto::TableStruct;
  friend void ::protobuf_tsm_2eproto::InitDefaultsUnfollowCommandImpl();
};
// -------------------------------------------------------------------

class GeneralStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tsm.GeneralStatus) */ {
 public:
  GeneralStatus();
  virtual ~GeneralStatus();

  GeneralStatus(const GeneralStatus& from);

  inline GeneralStatus& operator=(const GeneralStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GeneralStatus(GeneralStatus&& from) noexcept
    : GeneralStatus() {
    *this = ::std::move(from);
  }

  inline GeneralStatus& operator=(GeneralStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GeneralStatus& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GeneralStatus* internal_default_instance() {
    return reinterpret_cast<const GeneralStatus*>(
               &_GeneralStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(GeneralStatus* other);
  friend void swap(GeneralStatus& a, GeneralStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GeneralStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  GeneralStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GeneralStatus& from);
  void MergeFrom(const GeneralStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GeneralStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tsm.GStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::tsm::GStatus status() const;
  void set_status(::tsm::GStatus value);

  // @@protoc_insertion_point(class_scope:tsm.GeneralStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_tsm_2eproto::TableStruct;
  friend void ::protobuf_tsm_2eproto::InitDefaultsGeneralStatusImpl();
};
// -------------------------------------------------------------------

class ListReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tsm.ListReply) */ {
 public:
  ListReply();
  virtual ~ListReply();

  ListReply(const ListReply& from);

  inline ListReply& operator=(const ListReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ListReply(ListReply&& from) noexcept
    : ListReply() {
    *this = ::std::move(from);
  }

  inline ListReply& operator=(ListReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ListReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ListReply* internal_default_instance() {
    return reinterpret_cast<const ListReply*>(
               &_ListReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(ListReply* other);
  friend void swap(ListReply& a, ListReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ListReply* New() const PROTOBUF_FINAL { return New(NULL); }

  ListReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ListReply& from);
  void MergeFrom(const ListReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ListReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string users = 2;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 2;
  const ::std::string& users(int index) const;
  ::std::string* mutable_users(int index);
  void set_users(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_users(int index, ::std::string&& value);
  #endif
  void set_users(int index, const char* value);
  void set_users(int index, const char* value, size_t size);
  ::std::string* add_users();
  void add_users(const ::std::string& value);
  #if LANG_CXX11
  void add_users(::std::string&& value);
  #endif
  void add_users(const char* value);
  void add_users(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& users() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_users();

  // repeated string followings = 3;
  int followings_size() const;
  void clear_followings();
  static const int kFollowingsFieldNumber = 3;
  const ::std::string& followings(int index) const;
  ::std::string* mutable_followings(int index);
  void set_followings(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_followings(int index, ::std::string&& value);
  #endif
  void set_followings(int index, const char* value);
  void set_followings(int index, const char* value, size_t size);
  ::std::string* add_followings();
  void add_followings(const ::std::string& value);
  #if LANG_CXX11
  void add_followings(::std::string&& value);
  #endif
  void add_followings(const char* value);
  void add_followings(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& followings() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_followings();

  // .tsm.GStatus status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::tsm::GStatus status() const;
  void set_status(::tsm::GStatus value);

  // @@protoc_insertion_point(class_scope:tsm.ListReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> users_;
  ::google::protobuf::RepeatedPtrField< ::std::string> followings_;
  int status_;
  mutable int _cached_size_;
  friend struct ::protobuf_tsm_2eproto::TableStruct;
  friend void ::protobuf_tsm_2eproto::InitDefaultsListReplyImpl();
};
// -------------------------------------------------------------------

class ClientPost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tsm.ClientPost) */ {
 public:
  ClientPost();
  virtual ~ClientPost();

  ClientPost(const ClientPost& from);

  inline ClientPost& operator=(const ClientPost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientPost(ClientPost&& from) noexcept
    : ClientPost() {
    *this = ::std::move(from);
  }

  inline ClientPost& operator=(ClientPost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientPost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientPost* internal_default_instance() {
    return reinterpret_cast<const ClientPost*>(
               &_ClientPost_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(ClientPost* other);
  friend void swap(ClientPost& a, ClientPost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientPost* New() const PROTOBUF_FINAL { return New(NULL); }

  ClientPost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ClientPost& from);
  void MergeFrom(const ClientPost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ClientPost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 2;
  void clear_content();
  static const int kContentFieldNumber = 2;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // int64 sender = 1;
  void clear_sender();
  static const int kSenderFieldNumber = 1;
  ::google::protobuf::int64 sender() const;
  void set_sender(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tsm.ClientPost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::int64 sender_;
  mutable int _cached_size_;
  friend struct ::protobuf_tsm_2eproto::TableStruct;
  friend void ::protobuf_tsm_2eproto::InitDefaultsClientPostImpl();
};
// -------------------------------------------------------------------

class ServerPost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tsm.ServerPost) */ {
 public:
  ServerPost();
  virtual ~ServerPost();

  ServerPost(const ServerPost& from);

  inline ServerPost& operator=(const ServerPost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ServerPost(ServerPost&& from) noexcept
    : ServerPost() {
    *this = ::std::move(from);
  }

  inline ServerPost& operator=(ServerPost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerPost& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ServerPost* internal_default_instance() {
    return reinterpret_cast<const ServerPost*>(
               &_ServerPost_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(ServerPost* other);
  friend void swap(ServerPost& a, ServerPost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ServerPost* New() const PROTOBUF_FINAL { return New(NULL); }

  ServerPost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ServerPost& from);
  void MergeFrom(const ServerPost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ServerPost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string content = 1;
  void clear_content();
  static const int kContentFieldNumber = 1;
  const ::std::string& content() const;
  void set_content(const ::std::string& value);
  #if LANG_CXX11
  void set_content(::std::string&& value);
  #endif
  void set_content(const char* value);
  void set_content(const char* value, size_t size);
  ::std::string* mutable_content();
  ::std::string* release_content();
  void set_allocated_content(::std::string* content);

  // string senderName = 3;
  void clear_sendername();
  static const int kSenderNameFieldNumber = 3;
  const ::std::string& sendername() const;
  void set_sendername(const ::std::string& value);
  #if LANG_CXX11
  void set_sendername(::std::string&& value);
  #endif
  void set_sendername(const char* value);
  void set_sendername(const char* value, size_t size);
  ::std::string* mutable_sendername();
  ::std::string* release_sendername();
  void set_allocated_sendername(::std::string* sendername);

  // int32 time = 2;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::int32 time() const;
  void set_time(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tsm.ServerPost)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr content_;
  ::google::protobuf::internal::ArenaStringPtr sendername_;
  ::google::protobuf::int32 time_;
  mutable int _cached_size_;
  friend struct ::protobuf_tsm_2eproto::TableStruct;
  friend void ::protobuf_tsm_2eproto::InitDefaultsServerPostImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// UserName

// string name = 1;
inline void UserName::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserName::name() const {
  // @@protoc_insertion_point(field_get:tsm.UserName.name)
  return name_.GetNoArena();
}
inline void UserName::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tsm.UserName.name)
}
#if LANG_CXX11
inline void UserName::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tsm.UserName.name)
}
#endif
inline void UserName::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tsm.UserName.name)
}
inline void UserName::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tsm.UserName.name)
}
inline ::std::string* UserName::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tsm.UserName.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserName::release_name() {
  // @@protoc_insertion_point(field_release:tsm.UserName.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserName::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tsm.UserName.name)
}

// -------------------------------------------------------------------

// UserId

// int64 id = 1;
inline void UserId::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 UserId::id() const {
  // @@protoc_insertion_point(field_get:tsm.UserId.id)
  return id_;
}
inline void UserId::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:tsm.UserId.id)
}

// -------------------------------------------------------------------

// FollowCommand

// int64 sender = 1;
inline void FollowCommand::clear_sender() {
  sender_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FollowCommand::sender() const {
  // @@protoc_insertion_point(field_get:tsm.FollowCommand.sender)
  return sender_;
}
inline void FollowCommand::set_sender(::google::protobuf::int64 value) {
  
  sender_ = value;
  // @@protoc_insertion_point(field_set:tsm.FollowCommand.sender)
}

// string nameToFollow = 2;
inline void FollowCommand::clear_nametofollow() {
  nametofollow_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FollowCommand::nametofollow() const {
  // @@protoc_insertion_point(field_get:tsm.FollowCommand.nameToFollow)
  return nametofollow_.GetNoArena();
}
inline void FollowCommand::set_nametofollow(const ::std::string& value) {
  
  nametofollow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tsm.FollowCommand.nameToFollow)
}
#if LANG_CXX11
inline void FollowCommand::set_nametofollow(::std::string&& value) {
  
  nametofollow_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tsm.FollowCommand.nameToFollow)
}
#endif
inline void FollowCommand::set_nametofollow(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nametofollow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tsm.FollowCommand.nameToFollow)
}
inline void FollowCommand::set_nametofollow(const char* value, size_t size) {
  
  nametofollow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tsm.FollowCommand.nameToFollow)
}
inline ::std::string* FollowCommand::mutable_nametofollow() {
  
  // @@protoc_insertion_point(field_mutable:tsm.FollowCommand.nameToFollow)
  return nametofollow_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FollowCommand::release_nametofollow() {
  // @@protoc_insertion_point(field_release:tsm.FollowCommand.nameToFollow)
  
  return nametofollow_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FollowCommand::set_allocated_nametofollow(::std::string* nametofollow) {
  if (nametofollow != NULL) {
    
  } else {
    
  }
  nametofollow_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nametofollow);
  // @@protoc_insertion_point(field_set_allocated:tsm.FollowCommand.nameToFollow)
}

// -------------------------------------------------------------------

// UnfollowCommand

// int64 sender = 1;
inline void UnfollowCommand::clear_sender() {
  sender_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 UnfollowCommand::sender() const {
  // @@protoc_insertion_point(field_get:tsm.UnfollowCommand.sender)
  return sender_;
}
inline void UnfollowCommand::set_sender(::google::protobuf::int64 value) {
  
  sender_ = value;
  // @@protoc_insertion_point(field_set:tsm.UnfollowCommand.sender)
}

// string nameToUnfollow = 2;
inline void UnfollowCommand::clear_nametounfollow() {
  nametounfollow_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UnfollowCommand::nametounfollow() const {
  // @@protoc_insertion_point(field_get:tsm.UnfollowCommand.nameToUnfollow)
  return nametounfollow_.GetNoArena();
}
inline void UnfollowCommand::set_nametounfollow(const ::std::string& value) {
  
  nametounfollow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tsm.UnfollowCommand.nameToUnfollow)
}
#if LANG_CXX11
inline void UnfollowCommand::set_nametounfollow(::std::string&& value) {
  
  nametounfollow_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tsm.UnfollowCommand.nameToUnfollow)
}
#endif
inline void UnfollowCommand::set_nametounfollow(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  nametounfollow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tsm.UnfollowCommand.nameToUnfollow)
}
inline void UnfollowCommand::set_nametounfollow(const char* value, size_t size) {
  
  nametounfollow_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tsm.UnfollowCommand.nameToUnfollow)
}
inline ::std::string* UnfollowCommand::mutable_nametounfollow() {
  
  // @@protoc_insertion_point(field_mutable:tsm.UnfollowCommand.nameToUnfollow)
  return nametounfollow_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UnfollowCommand::release_nametounfollow() {
  // @@protoc_insertion_point(field_release:tsm.UnfollowCommand.nameToUnfollow)
  
  return nametounfollow_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UnfollowCommand::set_allocated_nametounfollow(::std::string* nametounfollow) {
  if (nametounfollow != NULL) {
    
  } else {
    
  }
  nametounfollow_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nametounfollow);
  // @@protoc_insertion_point(field_set_allocated:tsm.UnfollowCommand.nameToUnfollow)
}

// -------------------------------------------------------------------

// GeneralStatus

// .tsm.GStatus status = 1;
inline void GeneralStatus::clear_status() {
  status_ = 0;
}
inline ::tsm::GStatus GeneralStatus::status() const {
  // @@protoc_insertion_point(field_get:tsm.GeneralStatus.status)
  return static_cast< ::tsm::GStatus >(status_);
}
inline void GeneralStatus::set_status(::tsm::GStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:tsm.GeneralStatus.status)
}

// -------------------------------------------------------------------

// ListReply

// .tsm.GStatus status = 1;
inline void ListReply::clear_status() {
  status_ = 0;
}
inline ::tsm::GStatus ListReply::status() const {
  // @@protoc_insertion_point(field_get:tsm.ListReply.status)
  return static_cast< ::tsm::GStatus >(status_);
}
inline void ListReply::set_status(::tsm::GStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:tsm.ListReply.status)
}

// repeated string users = 2;
inline int ListReply::users_size() const {
  return users_.size();
}
inline void ListReply::clear_users() {
  users_.Clear();
}
inline const ::std::string& ListReply::users(int index) const {
  // @@protoc_insertion_point(field_get:tsm.ListReply.users)
  return users_.Get(index);
}
inline ::std::string* ListReply::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:tsm.ListReply.users)
  return users_.Mutable(index);
}
inline void ListReply::set_users(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tsm.ListReply.users)
  users_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ListReply::set_users(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tsm.ListReply.users)
  users_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ListReply::set_users(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  users_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tsm.ListReply.users)
}
inline void ListReply::set_users(int index, const char* value, size_t size) {
  users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tsm.ListReply.users)
}
inline ::std::string* ListReply::add_users() {
  // @@protoc_insertion_point(field_add_mutable:tsm.ListReply.users)
  return users_.Add();
}
inline void ListReply::add_users(const ::std::string& value) {
  users_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tsm.ListReply.users)
}
#if LANG_CXX11
inline void ListReply::add_users(::std::string&& value) {
  users_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tsm.ListReply.users)
}
#endif
inline void ListReply::add_users(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  users_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tsm.ListReply.users)
}
inline void ListReply::add_users(const char* value, size_t size) {
  users_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tsm.ListReply.users)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListReply::users() const {
  // @@protoc_insertion_point(field_list:tsm.ListReply.users)
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListReply::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:tsm.ListReply.users)
  return &users_;
}

// repeated string followings = 3;
inline int ListReply::followings_size() const {
  return followings_.size();
}
inline void ListReply::clear_followings() {
  followings_.Clear();
}
inline const ::std::string& ListReply::followings(int index) const {
  // @@protoc_insertion_point(field_get:tsm.ListReply.followings)
  return followings_.Get(index);
}
inline ::std::string* ListReply::mutable_followings(int index) {
  // @@protoc_insertion_point(field_mutable:tsm.ListReply.followings)
  return followings_.Mutable(index);
}
inline void ListReply::set_followings(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tsm.ListReply.followings)
  followings_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void ListReply::set_followings(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tsm.ListReply.followings)
  followings_.Mutable(index)->assign(std::move(value));
}
#endif
inline void ListReply::set_followings(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  followings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tsm.ListReply.followings)
}
inline void ListReply::set_followings(int index, const char* value, size_t size) {
  followings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tsm.ListReply.followings)
}
inline ::std::string* ListReply::add_followings() {
  // @@protoc_insertion_point(field_add_mutable:tsm.ListReply.followings)
  return followings_.Add();
}
inline void ListReply::add_followings(const ::std::string& value) {
  followings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tsm.ListReply.followings)
}
#if LANG_CXX11
inline void ListReply::add_followings(::std::string&& value) {
  followings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tsm.ListReply.followings)
}
#endif
inline void ListReply::add_followings(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  followings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tsm.ListReply.followings)
}
inline void ListReply::add_followings(const char* value, size_t size) {
  followings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tsm.ListReply.followings)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ListReply::followings() const {
  // @@protoc_insertion_point(field_list:tsm.ListReply.followings)
  return followings_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ListReply::mutable_followings() {
  // @@protoc_insertion_point(field_mutable_list:tsm.ListReply.followings)
  return &followings_;
}

// -------------------------------------------------------------------

// ClientPost

// int64 sender = 1;
inline void ClientPost::clear_sender() {
  sender_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientPost::sender() const {
  // @@protoc_insertion_point(field_get:tsm.ClientPost.sender)
  return sender_;
}
inline void ClientPost::set_sender(::google::protobuf::int64 value) {
  
  sender_ = value;
  // @@protoc_insertion_point(field_set:tsm.ClientPost.sender)
}

// string content = 2;
inline void ClientPost::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ClientPost::content() const {
  // @@protoc_insertion_point(field_get:tsm.ClientPost.content)
  return content_.GetNoArena();
}
inline void ClientPost::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tsm.ClientPost.content)
}
#if LANG_CXX11
inline void ClientPost::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tsm.ClientPost.content)
}
#endif
inline void ClientPost::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tsm.ClientPost.content)
}
inline void ClientPost::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tsm.ClientPost.content)
}
inline ::std::string* ClientPost::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:tsm.ClientPost.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ClientPost::release_content() {
  // @@protoc_insertion_point(field_release:tsm.ClientPost.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ClientPost::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:tsm.ClientPost.content)
}

// -------------------------------------------------------------------

// ServerPost

// string content = 1;
inline void ServerPost::clear_content() {
  content_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerPost::content() const {
  // @@protoc_insertion_point(field_get:tsm.ServerPost.content)
  return content_.GetNoArena();
}
inline void ServerPost::set_content(const ::std::string& value) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tsm.ServerPost.content)
}
#if LANG_CXX11
inline void ServerPost::set_content(::std::string&& value) {
  
  content_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tsm.ServerPost.content)
}
#endif
inline void ServerPost::set_content(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tsm.ServerPost.content)
}
inline void ServerPost::set_content(const char* value, size_t size) {
  
  content_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tsm.ServerPost.content)
}
inline ::std::string* ServerPost::mutable_content() {
  
  // @@protoc_insertion_point(field_mutable:tsm.ServerPost.content)
  return content_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerPost::release_content() {
  // @@protoc_insertion_point(field_release:tsm.ServerPost.content)
  
  return content_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerPost::set_allocated_content(::std::string* content) {
  if (content != NULL) {
    
  } else {
    
  }
  content_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), content);
  // @@protoc_insertion_point(field_set_allocated:tsm.ServerPost.content)
}

// int32 time = 2;
inline void ServerPost::clear_time() {
  time_ = 0;
}
inline ::google::protobuf::int32 ServerPost::time() const {
  // @@protoc_insertion_point(field_get:tsm.ServerPost.time)
  return time_;
}
inline void ServerPost::set_time(::google::protobuf::int32 value) {
  
  time_ = value;
  // @@protoc_insertion_point(field_set:tsm.ServerPost.time)
}

// string senderName = 3;
inline void ServerPost::clear_sendername() {
  sendername_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ServerPost::sendername() const {
  // @@protoc_insertion_point(field_get:tsm.ServerPost.senderName)
  return sendername_.GetNoArena();
}
inline void ServerPost::set_sendername(const ::std::string& value) {
  
  sendername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tsm.ServerPost.senderName)
}
#if LANG_CXX11
inline void ServerPost::set_sendername(::std::string&& value) {
  
  sendername_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tsm.ServerPost.senderName)
}
#endif
inline void ServerPost::set_sendername(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sendername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tsm.ServerPost.senderName)
}
inline void ServerPost::set_sendername(const char* value, size_t size) {
  
  sendername_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tsm.ServerPost.senderName)
}
inline ::std::string* ServerPost::mutable_sendername() {
  
  // @@protoc_insertion_point(field_mutable:tsm.ServerPost.senderName)
  return sendername_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ServerPost::release_sendername() {
  // @@protoc_insertion_point(field_release:tsm.ServerPost.senderName)
  
  return sendername_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ServerPost::set_allocated_sendername(::std::string* sendername) {
  if (sendername != NULL) {
    
  } else {
    
  }
  sendername_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sendername);
  // @@protoc_insertion_point(field_set_allocated:tsm.ServerPost.senderName)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tsm

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tsm::GStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tsm::GStatus>() {
  return ::tsm::GStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tsm_2eproto__INCLUDED
